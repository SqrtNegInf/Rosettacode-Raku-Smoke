#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Permutations/Rank_of_a_permutation
#c# 2016-05-21 <RC
#m# MOAR: OK
#j#  JVM: OK
#n# don't test with high limits, slow...

srand 123456;

my @res;

#sub rank2inv ( $rank, $n = * ) { $rank.polymod( 1 ..^ $n ) }  # what exactly is the point of 'n = *'? 
sub rank2inv ( $rank, $n ) { $rank.polymod( 1 ..^ $n ) }
sub inv2rank ( @inv )      { [+] @inv Z× [\×] 1, 1, * + 1 … * }

sub inv2perm ( @inv, @items is copy = ^@inv.elems ) {
    my @perm;
    for @inv.reverse -> $i {
        @perm.append: @items.splice: $i, 1;
       #@perm.push:   @items.splice: $i, 1;    # why different results with '.push'? (cf. K/Knuth%27s_algorithm_S-2)
    }
    @perm;
}

sub perm2inv ( @perm ) {            # not in linear time 
    (
        { @perm[++$ .. *].grep( * < $^cur ).elems } for @perm;  
    ).reverse;
}    

for ^6 {
    my @row.push: $^rank;
    for ( *.&rank2inv(3) , &inv2perm, &perm2inv, &inv2rank )  -> &code {
        @row.push: code( @row[*-1] );
    }
    @res.push: @row.gist;
}

my $perms =  4;
my $n     = 12;

@res.push: 'Via BigInt rank';
for ( ( ^([×] 1 .. $n) ).pick($perms) ) {
    @res.push: ($^rank.&rank2inv($n).&inv2perm).gist; 
};

@res.push: 'Via inversion vectors';
for ( { my $i=0;  inv2perm (^++$i).roll xx $n } … *  ).unique( with => &[eqv] ).[^$perms] {
    @res.push: $_.gist;
};

@res.push: 'Via Raku method pick';
for ( { [(^$n).pick(*)] } … * ).unique( with => &[eqv] ).head($perms) {
    @res.push: $_.gist;
};

.say for @res;

my $moar = qq:to/END/;
[0 (0 0 0) [0 1 2] (0 0 0) 0]
[1 (0 1 0) [0 2 1] (0 1 0) 1]
[2 (0 0 1) [1 0 2] (0 0 1) 2]
[3 (0 1 1) [1 2 0] (0 1 1) 3]
[4 (0 0 2) [2 0 1] (0 0 2) 4]
[5 (0 1 2) [2 1 0] (0 1 2) 5]
Via BigInt rank
[3 6 7 0 4 1 11 5 10 8 9 2]
[5 8 2 9 10 1 7 6 0 4 11 3]
[5 7 11 2 9 1 0 6 4 8 10 3]
[4 1 9 3 6 2 5 8 11 10 7 0]
Via inversion vectors
[3 9 1 8 5 11 4 10 0 7 2 6]
[11 4 7 8 0 10 5 3 1 6 9 2]
[10 7 9 11 6 5 0 4 2 8 3 1]
[11 7 8 3 1 2 5 4 0 6 9 10]
Via Raku method pick
[1 4 2 5 0 10 3 6 11 7 9 8]
[7 11 4 2 10 8 0 9 6 1 3 5]
[2 10 11 6 5 4 3 0 1 7 8 9]
[6 4 9 0 7 11 5 2 8 3 10 1]
END

my $jvm = qq:to/END/;
[0 (0 0 0) [0 1 2] (0 0 0) 0]
[1 (0 1 0) [0 2 1] (0 1 0) 1]
[2 (0 0 1) [1 0 2] (0 0 1) 2]
[3 (0 1 1) [1 2 0] (0 1 1) 3]
[4 (0 0 2) [2 0 1] (0 0 2) 4]
[5 (0 1 2) [2 1 0] (0 1 2) 5]
Via BigInt rank
[3 2 9 8 6 5 1 7 10 11 4 0]
[6 0 11 5 1 4 3 9 2 7 10 8]
[9 6 3 11 0 7 4 8 1 10 5 2]
[4 7 1 5 9 0 2 3 8 10 6 11]
Via inversion vectors
[5 3 1 4 2 0 9 7 8 11 10 6]
[1 4 3 5 8 7 2 11 9 10 6 0]
[8 9 11 1 3 4 10 5 0 7 6 2]
[6 2 11 1 10 4 9 7 5 0 3 8]
Via Raku method pick
[5 7 8 9 10 3 0 6 4 2 1 11]
[1 11 8 2 10 3 6 7 4 9 5 0]
[0 9 4 8 10 1 11 6 5 2 3 7]
[1 11 2 6 5 3 9 7 0 8 10 4]
END

use Test;
is @res.join("\n"), chomp $*VM ~~ /jvm/ ?? $jvm !! $moar;
