#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Pick_random_element
#c# 2015-12-07 <>RC
#m# MOAR: OK
#j#  JVM: OK
#n# since this is a demo of rand/roll/pick, don't use myRNG, just keep updating results...
#n# 2023-01-08 Mac-Pro/iMac results have diverged, for unknown reason; track separately

srand 123456;

my @res;

# In a nutshell, picking an element from a list
# is implemented with a method conveniently called "pick":

@res.push: (1, 2, 3).pick;
# There are various ways of doing something similar, though.
# Raku has actually two methods (with associated functional forms)
# to return random elements depending on whether you are doing selection
# with or without replacement.
# Selection with replacement: (roll of a die)

@res.push: (1..6).roll;    # return one random value in the range 1 through 6
@res.push: (1..6).roll(3); # return a list of 3 random values in the range 1 through 6
#(1..6).roll(*); # return a lazy infinite list of random values in the range 1 through 6

# Selection without replacement: (pick a card from a deck)
# define the deck
my @deck = (<2 3 4 5 6 7 8 9 J Q K A>) X~ <S C H D>;
@res.push: @deck;
@res.push: @deck.pick;    # Pick a card
@res.push: @deck.pick(5); # Draw 5
@res.push: @deck.pick(*); # Get a shuffled deck

# Or you can always use the normal rand built-in
# to generate a subscript (which automatically truncates any fractional part):

my @array = <1 2 3 3 4 5 6>;
@res.push: @array[@array Ã— rand];

# However, the pick and roll methods (not to be confused
# with the pick-and-roll method in basketball) are more general
# insofar as they may be used on any enumerable type:

@res.push: Bool.pick;  # returns either True or False

.put for @res;

my $moar-terminal-mac-pro = qq:to/END/;
1
2
3 5 1
2S 2C 2H 2D 3S 3C 3H 3D 4S 4C 4H 4D 5S 5C 5H 5D 6S 6C 6H 6D 7S 7C 7H 7D 8S 8C 8H 8D 9S 9C 9H 9D JS JC JH JD QS QC QH QD KS KC KH KD AS AC AH AD
3D
QD 5D 8C QH 9C
JH KD AS 7H KC 9D JS 5D 4D 3C 3D 6S QD 5H 8D 2S 9C KS 3H 6C JC AC 9S QH 6D 8H AH 8C 5S 3S 9H 7D 5C QS QC 7S AD JD 8S 4H 7C 4S KH 2D 2H 2C 6H 4C
5
True
END

my $moar-cronjob-mac-pro = qq:to/END/;
1
1
5 4 4
2S 2C 2H 2D 3S 3C 3H 3D 4S 4C 4H 4D 5S 5C 5H 5D 6S 6C 6H 6D 7S 7C 7H 7D 8S 8C 8H 8D 9S 9C 9H 9D JS JC JH JD QS QC QH QD KS KC KH KD AS AC AH AD
4D
AS AC 7H KH 9D
QC 6C 5S 3H 4S 6D 5C AH 9D 2S JD 6H KD 7S JC 8D 7C AS 8S 9S QH 7H 5D 9H JH 6S QS KS 4H KH QD AC 4C KC JS 5H 2C 3D 9C 3S 7D AD 8H 2D 4D 2H 3C 8C
1
False
END

my $moar-terminal-imac = qq:to/END/;
1
2
5 4 5
2S 2C 2H 2D 3S 3C 3H 3D 4S 4C 4H 4D 5S 5C 5H 5D 6S 6C 6H 6D 7S 7C 7H 7D 8S 8C 8H 8D 9S 9C 9H 9D JS JC JH JD QS QC QH QD KS KC KH KD AS AC AH AD
8S
9D JC KH KD 7C
AC JH JD 6C 5S 3H 4S 6H KD 6S 9H 2S JC AS 3D 6D 9D 8C 7S KH 7H 8H QS 9C 5H 3C KS 5D QH 8S 4C AH JS 4H KC 4D QC QD 2C 9S 8D 2D AD 5C 7D 2H 3S 7C
1
False
END

my $moar-cronjob-imac = qq:to/END/;
1
1
4 2 3
2S 2C 2H 2D 3S 3C 3H 3D 4S 4C 4H 4D 5S 5C 5H 5D 6S 6C 6H 6D 7S 7C 7H 7D 8S 8C 8H 8D 9S 9C 9H 9D JS JC JH JD QS QC QH QD KS KC KH KD AS AC AH AD
JS
JH QS 6C 5S 3H
4C 7S 5H 6D JD 2S QD AH AD 7D QS 9H 8S 3D 8D JS 2C 8C 6H JH QH AS 7C KS 5S 5C 7H 5D 4D 6S KH 6C 9D 4H KC 3H 8H 9S 9C JC 2D 4S QC 2H AC KD 3S 3C
1
True
END

my $jvm = qq:to/END/;
2
3
6 2 2
2S 2C 2H 2D 3S 3C 3H 3D 4S 4C 4H 4D 5S 5C 5H 5D 6S 6C 6H 6D 7S 7C 7H 7D 8S 8C 8H 8D 9S 9C 9H 9D JS JC JH JD QS QC QH QD KS KC KH KD AS AC AH AD
5S
5D 2S JH KS AD
AD QH 5S 3D 2H JD 7H 2C 6S 3C 2D KC 3H 4S KD JS QC 4D 8C 7S 7D 9H 2S 4C KH QS 6D 5C 8H 9C 6H JH KS 6C JC 8S 5D AC 5H 7C 8D 9S 4H AH AS 9D QD 3S
4
False
END

use Test;
if qx/uname -a/ ~~ /'iMac'/ {
    is @res.join("\n"), chomp $*VM ~~ /jvm/ ?? $jvm !! $*IN.t ?? $moar-terminal-imac    !! $moar-cronjob-imac;
} else {
    is @res.join("\n"), chomp $*VM ~~ /jvm/ ?? $jvm !! $*IN.t ?? $moar-terminal-mac-pro !! $moar-cronjob-mac-pro;
}
