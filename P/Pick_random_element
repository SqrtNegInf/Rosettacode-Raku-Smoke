#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Pick_random_element
#c# 2015-12-07 <>RC
#m# MOAR: OK
#j#  JVM: OK
#n# since this is a demo of rand/roll/pick, don't use myRNG, just keep updating results...
#n# 2023-02-01 iMac results flapping, accept multiple 'correct' answers [and stop tracking 'terminal'  results]

srand 123456;

my @res;

# In a nutshell, picking an element from a list
# is implemented with a method conveniently called "pick":

@res.push: (1, 2, 3).pick;
# There are various ways of doing something similar, though.
# Raku has actually two methods (with associated functional forms)
# to return random elements depending on whether you are doing selection
# with or without replacement.
# Selection with replacement: (roll of a die)

@res.push: (1..6).roll;    # return one random value in the range 1 through 6
@res.push: (1..6).roll(3); # return a list of 3 random values in the range 1 through 6
#(1..6).roll(*); # return a lazy infinite list of random values in the range 1 through 6

# Selection without replacement: (pick a card from a deck)
# define the deck
my @deck = (<2 3 4 5 6 7 8 9 J Q K A>) X~ <S C H D>;
@res.push: @deck;
@res.push: @deck.pick;    # Pick a card
@res.push: @deck.pick(5); # Draw 5
@res.push: @deck.pick(*); # Get a shuffled deck

# Or you can always use the normal rand built-in
# to generate a subscript (which automatically truncates any fractional part):

my @array = <1 2 3 3 4 5 6>;
@res.push: @array[@array Ã— rand];

# However, the pick and roll methods (not to be confused
# with the pick-and-roll method in basketball) are more general
# insofar as they may be used on any enumerable type:

@res.push: Bool.pick;  # returns either True or False

.put for @res;

my $moar-cronjob-mac-pro = qq:to/END/;
1
1
5 4 4
2S 2C 2H 2D 3S 3C 3H 3D 4S 4C 4H 4D 5S 5C 5H 5D 6S 6C 6H 6D 7S 7C 7H 7D 8S 8C 8H 8D 9S 9C 9H 9D JS JC JH JD QS QC QH QD KS KC KH KD AS AC AH AD
4D
AS AC 7H KH 9D
QC 6C 5S 3H 4S 6D 5C AH 9D 2S JD 6H KD 7S JC 8D 7C AS 8S 9S QH 7H 5D 9H JH 6S QS KS 4H KH QD AC 4C KC JS 5H 2C 3D 9C 3S 7D AD 8H 2D 4D 2H 3C 8C
1
False
END

my $moar-cronjob-imac = qq:to/END/;
1
1
5 1 5
2S 2C 2H 2D 3S 3C 3H 3D 4S 4C 4H 4D 5S 5C 5H 5D 6S 6C 6H 6D 7S 7C 7H 7D 8S 8C 8H 8D 9S 9C 9H 9D JS JC JH JD QS QC QH QD KS KC KH KD AS AC AH AD
9S
QH 2S KD 7H 4H
9S AC QC 9H 4C JD KC 2C JC 7D KD 9D 8H AD 8D 6C 6H QS 7C JS 8S 2S KH 2H 6S 5H 4D 6D 5C KS 5S 3D 5D 8C QH AH 3H 4H 2D QD 3C 7S 4S 7H AS JH 3S 9C
3
False
END

my $moar-cronjob-ubuntu = qq:to/END/;
1
1
5 1 3
2S 2C 2H 2D 3S 3C 3H 3D 4S 4C 4H 4D 5S 5C 5H 5D 6S 6C 6H 6D 7S 7C 7H 7D 8S 8C 8H 8D 9S 9C 9H 9D JS JC JH JD QS QC QH QD KS KC KH KD AS AC AH AD
6S
5C 3H 4S 6D 5H
7S QC 2S KH 7H 4H 8C QD JS 8H 4S 9H JD 2C 9S AD AH QH 7C 7D KD 5H QS 5D 6C 5C 6D AC KS 2H 5S AS 9D 8D 4C 9C 8S 3S KC JC 6S 3C 2D 3D JH 4D 3H 6H
2
True
END

my $jvm = qq:to/END/;
2
3
6 2 2
2S 2C 2H 2D 3S 3C 3H 3D 4S 4C 4H 4D 5S 5C 5H 5D 6S 6C 6H 6D 7S 7C 7H 7D 8S 8C 8H 8D 9S 9C 9H 9D JS JC JH JD QS QC QH QD KS KC KH KD AS AC AH AD
5S
5D 2S JH KS AD
AD QH 5S 3D 2H JD 7H 2C 6S 3C 2D KC 3H 4S KD JS QC 4D 8C 7S 7D 9H 2S 4C KH QS 6D 5C 8H 9C 6H JH KS 6C JC 8S 5D AC 5H 7C 8D 9S 4H AH AS 9D QD 3S
4
False
END

use Test;
if qx/uname/ ~~ /'Linux'/ {
    is @res.join("\n"), chomp $moar-cronjob-ubuntu;
} else {
if qx/uname -a/ ~~ /'iMac'/ {
    ok (   (@res.join("\n") eq chomp $moar-cronjob-mac-pro)
        or (@res.join("\n") eq chomp $moar-cronjob-imac   )  
       )
} else {
    is @res.join("\n"), chomp $*VM ~~ /jvm/ ?? $jvm !! $moar-cronjob-mac-pro;
}
}
