#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Modular_inverse
#c# 2015-10-25 <RC, 2024-09-15 <RC
#m# MOAR: OK
#j#  JVM: OK

sub inverse($n, :$modulo) {
    my ($c, $d, $uc, $vc, $ud, $vd) = ($n % $modulo, $modulo, 1, 0, 0, 1);
    my $q;
    while $c != 0 {
        ($q, $c, $d) = ($d div $c, $d % $c, $c);
        ($uc, $vc, $ud, $vd) = ($ud - $q×$uc, $vd - $q×$vc, $uc, $vc);
    }
    return $ud % $modulo;
}

say inverse 42, :modulo(2017);

# or use a built-in routine - https://docs.raku.org/routine/expmod , kudos to trizen++
say expmod(42, -1, 2017);

use Test;
is (inverse 42, :modulo(2017)), 1969;
is (expmod(42, -1, 2017)     ), 1969;
