#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Eisenstein_primes
#t# inprogress
#c# 2023-06-xx >RC
#m# MOAR: OK
#j#  JVM: OK

# An Eisenstein integer is a non-unit Gaussian integer a + bω where ω(1+ω) = -1, and a and b are integers.
# An Eisenstein integer a + bω is a prime if either it is 
#    a product of a unit and an integer prime p such that p % 3 == 2 
# or
#    norm(a + bω) is an integer prime.

my \ω = exp 2i × π/3;
#my \ω = ( -1 + i × 3.sqrt ) / 2;
#say ω; say ω×(1+ω);

sub norm ($a,$b)    { $a² - $a×$b + $b² } 
sub display ($a,$b) { sprintf "%+8.4f%+8.4fi", ($a + ω×$b).reals }

# generate an excess, but not Inf
my @ES = gather (1..20 X 1..20).map: -> (\a,\b) { take (a,b) if norm(a,b).is-prime or .is-prime && 2 == $_ mod 3 given (a,b).max } 

(reverse @ES.sort: -> $a, $b { norm($a,$b) }).head(100).map( {display(.[0],.[1])} ).batch(4).join("\n").say;
#(reverse @ES.sort: -> $a, $b { norm($a,$b) }).head(100).map({sprintf "%+8.4f%+8.4fi",(.[0] + ω ×.[1]).reals}).batch(4).join("\n").say;
#@ES[^100].map({(.[0] + ω ×.[1]).reals.fmt("%+8.4f%+8.4fi")}).batch(4).join("\n").say; # 2 vs 1 @ fmt
#@ES.sort( { norm(@($^a)) <=> norm(@($^b)) } ).head(100).map({sprintf "%+8.4f%+8.4fi",(.[0] + ω ×.[1]).reals}).batch(4).join("\n").say;

my $ref = q:to/EOD/;
EOD

use Test;
#is $result, $ref;

