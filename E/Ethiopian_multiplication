#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Ethiopian_multiplication
#c# 2016-03-23 <RC
#m# MOAR: OK
#j#  JVM: OK

sub halve  (Int $n is rw)    { $n div= 2 }
sub double (Int $n is rw)    { $n ×= 2 }
sub even   (Int $n --> Bool) { $n %% 2 }

sub ethiopic-mult (Int $a is copy, Int $b is copy --> Int) {
    my Int $r = 0;
    while $a {
	even $a or $r += $b;
	halve $a;
	double $b;
    }
    return $r;
}


#More succinctly using implicit typing, primed lambdas, and an infinite loop:

sub ethiopic-mult0 {
    my &halve  = * div= 2;
    my &double = * ×= 2;
    my &even   = * %% 2;

    my ($a,$b) = @_;
    my $r;
    loop {
        even  $a or $r += $b;
        halve $a or return $r;
        double $b;
    }
}

# More succinctly still, using a pure functional approach (reductions, mappings, lazy infinite sequences):

sub halve1  { $^n div 2 }
sub double1 { $^n × 2   }
sub even1   { $^n %% 2  }

sub ethiopic-mult1 ($a, $b) {
    [+] ($b, &double1 ... *)
        Z×
        ($a, &halve1 ... 0).map: { not even1 $^n }
}

use Test;
is ethiopic-mult(17,34), 578;
is ethiopic-mult0(17,34), 578;
is ethiopic-mult1(17,34), 578;
