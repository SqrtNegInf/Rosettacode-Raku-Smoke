#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm
#c# 2020-02-24 <RC, 2020-02-28 <RC
#m# MOAR: OK
#j# JVM:  OK
#n# 2020-10-12 fails only under conditions of high system load?
#n# 2020-10-14 when running with the 'solo' group no errors
#n# 2020-10-15 drats, foiled again, still fails

srand 123456;

my @res;

use Digest::SHA256::Native;
 
# Following data taken from the C entry
our (\A,\B,\P,\O,\Gx,\Gy) = (355, 671, 1073741789, 1073807281, 13693, 10088);
 
#`{ Following data taken from the Julia entry; 256-bit; tested
our (\A,\B,\P,\O,\Gx,\Gy) = (0, 7, # https://en.bitcoin.it/wiki/Secp256k1
:10("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F"),
:10("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141"),
:10("0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798"),
:10("0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8")); # }
 
role Horizon { method gist { 'EC Point at horizon' } }
 
class Point {             # modified from the Elliptic_curve_arithmetic entry
   has ($.x, $.y);        # handle modular arithmetic only
   multi method new( \x, \y ) { self.bless(:x, :y) }
   method gist { "EC Point at x=$.x, y=$.y" }
   method isOn { modP(B + $.x Ã— modP(A+$.xÂ²)) == modP($.yÂ²) }
   sub modP ($a is copy) { ( $a %= P ) < 0 ?? ($a += P) !! $a }
}
 
multi infix:<âŠ>(Point \p, Point \q) {
   my \Î» = $; # slope
   if p.x ~~ q.x and p.y ~~ q.y {
      return Horizon if p.y == 0 ;
      Î» = (3Ã—p.xÂ²+ A) Ã— mult_inv(2Ã—p.y, :modulo(P))
   } else {
      Î» = (p.y - q.y) Ã— mult_inv(p.x - q.x, :modulo(P))
   }
   my \xr = (Î»Â²- p.x - q.x);
   my \yr = (Î»Ã—(p.x - xr) - p.y);
   return Point.bless: x =>  xr % P, y => yr % P
}
 
multi infix:<âŠ >(Int \n, Point \p) {
   return 0                if n == 0 ;
   return p                if n == 1 ;
   return p âŠ ((n-1) âŠ  p ) if n % 2 == 1 ;
   return ( n div 2 ) âŠ  ( p âŠ p )
}
 
sub mult_inv($n, :$modulo) { # rosettacode.org/wiki/Modular_inverse
   my ($c, $d, $uc, $vd, $vc, $ud, $q) = $n % $modulo, $modulo, 1, 1, 0, 0, 0;
   while $c != 0 {
      ($q, $c, $d) = ($d div $c, $d % $c, $c);
      ($uc, $vc, $ud, $vd) = ($ud - $qÃ—$uc, $vd - $qÃ—$vc, $uc, $vc);
   }
   return $ud % $modulo;
}
 
class Signature {
 
   has ($.n, Point $.G); # Order and Generator point
 
   method generate_signature(Int \private_key, Str \msg) {
      #my \z = :16((sha256 msg).list>>.&{"%02s".sprintf(.base(16))}.join) % $.n;
      my \z = :16(sha256-hex msg) % $.n; # self ref: Blob.list.fmt("%02X",'')
      loop (my $k = my $s = my $r = 0 ; $s == 0 ; ) {
         loop ($r = $s = 0 ; $r == 0 ; ) {
            $r = (( $k = (1..^$.n).roll ) âŠ  $.G).x % $.n;
         }
         $s = ((z + $rÃ—private_key) Ã— mult_inv $k, :modulo($.n)) % $.n;
      }
      return $r, $s, private_key âŠ  $.G ;
   }
 
   method verify_signature(\msg, \r, \s, \public_key) {
      #my \z = :16((sha256 msg).list>>.&{"%02s".sprintf(.base(16))}.join) % $.n;
      my \z = :16(sha256-hex msg) % $.n;
      my \w = mult_inv s, :modulo($.n);
      my (\u1,\u2) = (zÃ—w, rÃ—w)>>.&{ $_ % $.n }
      my \p = (u1 âŠ  $.G ) âŠ (u2 âŠ  public_key);
      return (p.x % $.n) == (r % $.n)
   }
}
 
@res.push: "The Curve E is        : " ~ "ğ‘¦Â² = ğ‘¥Â³ + %s ğ‘¥ + %s (mod %s) ".sprintf(A,B,P);
@res.push: "with Generator G at   : (%s,%s)".sprintf(Gx,Gy);
my $ec = Signature.new: n => O, G => Point.new: x => Gx, y => Gy ;
@res.push: "Order(G, E) is        : "~ O;
@res.push: "Is G  âˆˆ E ?           : "~ $ec.G.isOn;
@res.push: "Message               : "~ my \message = "Show me the monKey";
@res.push: "The private key dA is : "~ my \dA = (1..^O).roll;
my ($r, $s, \Qa) = $ec.generate_signature(dA, message);
@res.push: "The public  key Qa is : "~ Qa.gist;
@res.push: "Is Qa âˆˆ E ?           : "~ Qa.isOn;
@res.push: "Is signature valid?   : "~ $ec.verify_signature(message, $r, $s, Qa);
@res.push: "Message (Tampered)    : "~ my \altered = "Show me the money";
@res.push: "Is signature valid?   : "~ $ec.verify_signature(altered, $r, $s, Qa);

.say for @res;

my $moar = q:to/END/;
The Curve E is        : ğ‘¦Â² = ğ‘¥Â³ + 355 ğ‘¥ + 671 (mod 1073741789) 
with Generator G at   : (13693,10088)
Order(G, E) is        : 1073807281
Is G  âˆˆ E ?           : True
Message               : Show me the monKey
The private key dA is : 418038534
The public  key Qa is : EC Point at x=142154383, y=688845509
Is Qa âˆˆ E ?           : True
Is signature valid?   : True
Message (Tampered)    : Show me the money
Is signature valid?   : False
END

my $jvm = q:to/END/;
The Curve E is        : ğ‘¦Â² = ğ‘¥Â³ + 355 ğ‘¥ + 671 (mod 1073741789) 
with Generator G at   : (13693,10088)
Order(G, E) is        : 1073807281
Is G  âˆˆ E ?           : True
Message               : Show me the monKey
The private key dA is : 666683498
The public  key Qa is : EC Point at x=1016062020, y=1061016630
Is Qa âˆˆ E ?           : True
Is signature valid?   : True
Message (Tampered)    : Show me the money
Is signature valid?   : False
END

use Test;
my $ref = $*VM ~~ /jvm/ ?? $jvm !! $moar;
is @res.join("\n"), chomp $ref;
