#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Dinesman's_multiple-dwelling_problem solution 1
#c# 2015-11-14 <>RC
#m# MOAR: OK
#j#  JVM: BROKEN
#n# for JVM: $expr not set, grammar fails
#n# .EVAL syntax doesn't work here?

#c# 2016-10-20 <RC
#   $c used as a state variable/ counter, '$' ceased to work
#   started failing on:
#   This is Rakudo version 2016.10-24-g74d0e36 built on MoarVM version 2016.10-15-g715e39a

use MONKEY-SEE-NO-EVAL;

sub parse_and_solve ($text) {
    my %ids;
    my $expr = (grammar { 
        state $c = 0;
        rule TOP { <fact>+ { make join ' && ', $<fact>>>.made } }

        rule fact { <name> (not)? <position>
                    { make sprintf $<position>.made.fmt($0 ??  "!(%s)" !! "%s"),
                                   $<name>.made }
        }
        rule position {
            || on bottom             { make "\@f[%s] == 1"                            }
            || on top                { make "\@f[%s] == +\@f"                         }
            || lower than <name>     { make "\@f[%s] < \@f[{$<name>.made}]"           }
            || higher than <name>    { make "\@f[%s] > \@f[{$<name>.made}]"           }
            || directly below <name> { make "\@f[%s] == \@f[{$<name>.made}] - 1"      }
            || directly above <name> { make "\@f[%s] == \@f[{$<name>.made}] + 1"      }
            || adjacent to <name>    { make "\@f[%s] == \@f[{$<name>.made}] + (-1|1)" }
            || on <ordinal>          { make "\@f[%s] == {$<ordinal>.made}"            }
            || { note "Failed to parse line " ~ +$/.prematch.comb(/^^/); exit 1; }
        }

        token name    { :i <[a..z]>+              { make %ids{~$/} //= $c++ } }
        token ordinal { [1st | 2nd | 3rd | \d+th] { make +$/.match(/(\d+)/)[0]     } }
    }).parse($text).made;

    EVAL 'for [1..%ids.elems].permutations -> @f {
              take %ids.kv.map({ "$^a=@f[$^b]" }) if (' ~ $expr ~ ');
          }'
}

.say for my @res = sort gather {
parse_and_solve Q:to/END/;
    Baker not on top
    Cooper not on bottom
    Fletcher not on top
    Fletcher not on bottom
    Miller higher than Cooper
    Smith not adjacent to Fletcher
    Fletcher not adjacent to Cooper
    END
}.split(" ");

my $ref = qq:to/END/;
Baker=3
Cooper=2
Fletcher=4
Miller=5
Smith=1
END

use Test;
is @res.join("\n"), chomp $ref;
