#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Fibonacci_matrix-exponentiation
#c# 2020-02-05 >RC
#p# OK
#n# works for 16/32, not 64:
#n#   first20: no error, but bogus value 11175807536929531904
#n#   last20:  Math::AnyNum / 'fibmod': Cannot unbox 65 bit wide bigint into native integer

my @res;

use lib 'lib';
use Math::Matrix;  

use Inline::Perl5;
my $p5 = Inline::Perl5.new();
$p5.use( 'Math::AnyNum' );

constant D = 70;    # sets the size of FatRat calcluations

# matrix exponentiation
sub fibonacci ($n) {
    my $M = Math::Matrix.new( [[1,1],[1,0]] );
    ($M ** $n)[0][1];
}

# calculation of ùëí
sub postfix:<!> (Int $n) { (constant f = 1, |[\√ó] 1..*)[$n] }
sub ùëí (--> FatRat) { sum map { FatRat.new(1,.!) }, ^D }

# calculation of œÄ
sub œÄ (--> FatRat) {
    my ($a, $n, $g, $z, $pi) = 1, 1, sqrt(1/2.FatRat), 0.25;

    for ^5 {  # converges quickly...
        given [ ($a + $g)/2, sqrt $a √ó $g ] {  
            $z -= (.[0] - $a)**2 √ó $n;
            $n += $n;
            ($a, $g) = @$_;
            $pi = ($a ** 2 / $z).substr: 0, 2 + D;
        }
    }

    $pi.FatRat;
}

# square-root: accepts/return FatRat
multi sqrt(FatRat $r --> FatRat) {
    FatRat.new: sqrt($r.nude[0] √ó 10**(D√ó2) div $r.nude[1]), 10**D;
}

# square-root: accepts/return Int
multi sqrt(Int $n) {
    my $guess = 10**($n.chars div 2);
    my $iterator = { ( $^x   +   $n div ($^x) ) div 2 };
    my $endpoint = { $^x == $^y|$^z };
    min ($guess, $iterator ‚Ä¶ $endpoint)[*-1, *-2];
}

# arithmetic-geometrix mean: accepts/returns FatRat
sub AG-mean( FatRat $a is copy, FatRat $g is copy --> FatRat) {
    ($a, $g) = ($a + $g)/2, sqrt $a √ó $g until $a - $g < 1e-40;
    $a;
}

# override built-in definitions with 'FatRat' versions
constant ùëí = &ùëí();
constant œÄ = &œÄ();

# approximation of natural log, returns FatRat
# calculated via arithmetic-geometrix mean (as per https://en.wikipedia.org/wiki/Logarithm#Calculation)
sub log-approx ($x --> FatRat) {
    constant ln2 = 0.69314718055994530941723212145817656807550013436.FatRat; # necessary boot-strapping 
    œÄ / (2 √ó AG-mean(1.FatRat, 2.FatRat**(2-D)/$x)) - D √ó ln2;
}

# power function, with exponent less than zero: accepts/returns FatRat
multi infix:<**> (FatRat $base, FatRat $exp is copy where * <  1 --> FatRat) {
    constant Œµ = 10**-D;
    my ($low, $high)  = 0.FatRat, 1.FatRat;
    my $mid  = $high / 2;
    my $acc  = my $sqr = sqrt($base);
    $exp *= -1;

    while (abs($mid - $exp) > Œµ) {
      $sqr = sqrt($sqr);
      if ($mid <= $exp) { $low  = $mid; $acc √ó=   $sqr }
      else              { $high = $mid; $acc √ó= 1/$sqr }
      $mid = ($low + $high) / 2;
    }

    (1/$acc).substr(0, D).FatRat;
}

sub binet_approx ($n) {
    constant PHI =   sqrt(1.25.FatRat) + 0.5 ;
    constant IHP = -(sqrt(1.25.FatRat) - 0.5);
    log-approx(PHI)*$n - log-approx(PHI - IHP);
}

sub nth_fib_first_k_digits ($n,$k) {
    my $f     = binet_approx($n);
    my $log10 = log-approx(10);
    floor( ùëí**($f - $log10*(floor($f/$log10 + 1))) * 10**$k);
}

my &nth_fib_last_k_digits = 
    $p5.run('sub { my($n,$k) = @_; Math::AnyNum::fibmod($n, 10**$k) }');

#say nth_fib_last_k_digits(2**64, 20);

# really slowing down by 20, and by 32 gobbles all CPU/memory
for (16) -> $n { #, 32) {
    my $f = fibonacci(2**$n);
    @res.push: "F(2^$n) = " ~ substr($f,0,20) ~ ' ... ' ~ $f % 10**20;
}
    
for 16, 32 -> $n { # 64
    my $first20 = nth_fib_first_k_digits(2**$n, 20);
    my $last20  = nth_fib_last_k_digits(2**$n, 20);
    #printf "F(2^$n) = %s ... %s\n", $first20, $last20;
    @res.push: sprintf "F(2^$n) = %s ... %s", $first20, $last20;
}

say my $result = join "\n", @res;

my $ref = q:to/END/;
F(2^16) = 73199214460290552832 ... 97270190955307463227
F(2^16) = 73199214460290552832 ... 97270190955307463227
F(2^32) = 61999319689381859818 ... 39623735538208076347
END
#F(2^64) = 11175807536929528424 ... 17529800348089840187

use Test;
is($result, chomp $ref);
