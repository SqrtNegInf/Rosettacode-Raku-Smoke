#!/usr/bin/env raku
#u# http://rosettacode.org/wiki/Free_polyominoes_enumeration
#t# inprogress
#c# 2022-xx-xx >RC
#m# MOAR: OK
#j#  JVM: OK
#n# from sidef/ruby
#n# OEIS:A000105

my @res;

sub translate2origin(\poly) {
  # Finds the min x and y coordiate of a Polyomino.
# my $minx = poly.map(:head).min;
# my $miny = poly.map(:tail).min;
  my $minx = min (flat poly).map: *.[0]; # flat if multiple?
  my $miny = min (     poly).map: *.[1]; # or not
  #poly.map {|p| [p.head-$minx, p.tail-$miny] }.sort
}

sub rotate90(\x,\y) { [ y, -x] }
sub  reflect(\x,\y) { [-x,  y] }

# All the plane symmetries of a rectangular region.
sub rotations_and_reflections(\poly) {
    gather {
        take(poly);
        take( rotate90(poly) ) for ^3;
        take( reflect(poly) );
        take( rotate90(poly) ) for ^3;
    }
}

sub canonical(\poly) {
  rotations_and_reflections(poly).map: -> \pl { translate2origin(pl) }
}

# All four points in Von Neumann neighborhood.
sub contiguous(\x, \y) {
  [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]
}

# Finds all distinct points that can be added to a Polyomino.
sub new_points(\poly) {
  my @points = Set();
  #poly.each { points << contiguous(_...)... }
  #points - poly
}

sub new_polys (\polys) {
#`{{
  my $pattern = Set()
  polys.map { |poly|
    gather {
      new_points(poly).each { |point|
        my $pl = translate2origin(poly + [point])
        next if $pattern.has($pl)
        take canonical($pl).each{ $pattern << _ }.min
      }
    }...
  }
}}
}

# Generates polyominoes of rank n recursively.
sub rank(\n) {
  given (n) {
    when (0) { [[]] }
    when (1) { [[[0,0]]] }
    default     { new_polys(rank(n-1)) }
  }
}

# Generates a textual representation of a Polyomino.
sub text_representation(\poly) {
  my %table = Hash();
  for poly -> \x, \y { %table{[x,y]} = '#' }
    #my $maxx = poly.map(:head).max;
    #my $maxy = poly.map(:tail).max;
    my $maxx = max poly.map: *.[0];
    my $maxy = max poly.map: *.[1];

    #(0..$maxx).map{|x| (0..$maxy).map{|y| %table{[x,y]} \\ ' ' }.join }
}

#say 8.of { rank(_).len }

my $n = 3;
say "\nAll free polyominoes of rank %d:", $n;
rank($n); #.sort.each{|poly| say text_representation(poly).join("\n")+"\n" }

# [1, 1, 1, 2, 5, 12, 35, 108]

use Test;
#my $ref = $*VM ~~ /jvm/ ?? $jvm !! $moar;
#is @res.join('').subst(/<ws>/, '', :g), $ref.subst(/<ws>/, '', :g);$
#is @res.join("\n"), chomp $ref;

=finish

=={{header|Raku}}==
<lang perl6>
</lang>
{{out}}
<pre style="height:20ex">
</pre>


All free polyominoes of rank 5:
#####

####
#   

####
 #  

###
## 

###
# #

###
#  
#  

###
 # 
 # 

### 
  ##

## 
 ##
 # 

## 
 ##
  #

## 
 # 
 ##

 # 
###
 # 
