#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Word_search
#c# 2020-02-07 <RC
#m# MOAR: OK
#j# JVM:  OK
#n# 2023-01-01 output fixed for now (see also '_exp' version), but also need to split Mac-Pro/iMac results

srand 123456;

my @res;

my $rows = 10;
my $cols = 10;

my $message = q:to/END/;
    .....R....
    ......O...
    .......S..
    ........E.
    T........T
    .A........
    ..C.......
    ...O......
    ....D.....
    .....E....
    END

my %dir =
    '→' => (1,0),
    '↘' => (1,1),
    '↓' => (0,1),
    '↙' => (-1,1),
    '←' => (-1,0),
    '↖' => (-1,-1),
    '↑' => (0,-1),
    '↗' => (1,-1)
;

my @ws = $message.comb(/<print>/);

my $path = './ref/unixdict.txt'; # or wherever

my @words = $path.IO.slurp.words.grep( { $_ !~~ /<-[a..z]>/ and 2 < .chars < 11 } ).pick(*);
my %index;
my %used;

while @ws.first( * eq '.') {

    # find an unfilled cell
    my $i = @ws.grep( * eq '.', :k ).pick;

    # translate the index to x / y coordinates
    my ($x, $y) = $i % $cols, floor($i / $rows);

    # find a word that fits
    my $word = find($x, $y);

    # Meh, reached an impasse, easier to just throw it all
    # away and start over rather than trying to backtrack.
    restart, next unless $word;

    %used{"$word"}++;

    # Keeps trying to place an already used word, choices
    # must be limited, start over
    restart, next if %used{$word} > 15;

    # Already used this word, try again
    next if %index{$word.key};

    # Add word to used word index
    %index ,= $word;

    # place the word into the grid
    place($x, $y, $word);

}

display();

sub display {
    @res.push: flat "    ", 'ABCDEFGHIJ'.comb;
    @res.push: $_ for (^10).map: { ($_).fmt("  %2d"), @ws[$_ × $cols .. ($_ + 1) × $cols - 1] }
    @res.push: "\n  Words used:";
    my $max = 1 + %index.keys.max( *.chars ).chars;
    for %index.sort {
        @res.push: sprintf "%{$max}s %4s %s  ", .key, .value.key, .value.value;
        #print "\n" if $++ % 2;
    }
    @res.push: "\n"
}

sub restart {
    @ws = $message.comb(/<print>/);
    %index = ();
    %used = ();
}

sub place ($x is copy, $y is copy, $w) {
    my @word = $w.key.comb;
    my $dir  = %dir{$w.value.value};
    @ws[$y × $rows + $x] = @word.shift;
    while @word {
        ($x, $y) »+=« $dir;
        @ws[$y × $rows + $x] = @word.shift;
    }
 }

sub find ($x, $y) {
    my @trials = %dir.keys.sort.map: -> $dir { # DH this sort is used just to get stable results for testing
            my $space = '.';
            my ($c, $r) = $x, $y;
            loop {
                ($c, $r) »+=« %dir{$dir};
                last if 9 < $r|$c;
                last if 0 > $r|$c;
                my $l = @ws[$r × $rows + $c];
                last if $l ~~ /<:Lu>/;
                $space ~= $l;
            }
            next if $space.chars < 3;
            [$space.trans( '.' => ' ' ),
            ("{'ABCDEFGHIJ'.comb[$x]} {$y}" => $dir)]
        };

    for @words.pick(*) -> $word {
        for @trials -> $space {
            next if $word.chars > $space[0].chars;
            return ($word => $space[1]) if compare($space[0].comb, $word.comb)
        }
    }
}

sub compare (@s, @w) {
    for ^@w {
        next if @s[$_] eq ' ';
        return False if @s[$_] ne @w[$_]
    }
    True
}

.put for @res;

my $moar-terminal = q:to/END/;
     A B C D E F G H I J
   0 l o s p g R e n a m
   1 d l e i f a O k o u
   2 n e t n a e t S r j
   3 a g a g e n t i E i
   4 T e r i f d l i w T
   5 n A p w h e t a n t
   6 o r C p i s t o l l
   7 p a e O t a e b l i
   8 e j t t D g n o b s
   9 w t e n o E b e y e

  Words used:
   afield  F 1 ←  
    agent  C 3 →  
      ant  H 5 →  
     ante  E 2 ←  
     beat  H 7 ←  
     bong  I 8 ←  
      end  F 2 ↓  
      eye  H 9 →  
      gel  B 3 ↑  
      irk  J 3 ↖  
      jar  B 8 ↑  
      jon  J 2 ↖  
     lise  J 6 ↓  
      lob  I 7 ↙  
     mane  J 0 ←  
      net  A 2 →  
      one  E 9 ←  
      pea  C 5 ↖  
      pew  A 7 ↓  
     ping  D 0 ↓  
   pistol  D 6 →  
      sol  C 0 ←  
      tag  G 2 ↖  
      tao  C 8 ↖  
      ten  B 9 →  
     tern  D 8 ↖  
      uri  J 1 ↙  
     whet  D 5 →  
 wildfire  I 4 ←  


END

my $moar-cronjob = q:to/END/;
     A B C D E F G H I J
   0 e g d e l R o a h c
   1 y f i t o n O a a f
   2 p o s s u m v S w s
   3 s t r a b i e s E n
   4 T b e c a m e x a T
   5 l A a a o c o s e t
   6 a v C x s y t t i w
   7 s g e O i e l o s d
   8 u n i t D s p u m e
   9 y e k r o E b u o y

  Words used:
    awn  H 1 ↘  
    axe  I 4 ←  
   axis  C 5 ↘  
 became  B 4 →  
   buoy  G 9 →  
   chao  J 0 ←  
  coset  F 5 →  
    dis  J 7 ↖  
    key  C 9 ←  
  ledge  E 0 ←  
 notify  F 1 ←  
    nsf  J 3 ↑  
   oxen  E 5 ↙  
 possum  A 2 →  
 rabies  C 3 →  
    rig  D 9 ↖  
    sal  A 7 ↑  
    sol  I 7 ←  
  spume  F 8 →  
    spy  A 3 ↑  
  tease  B 3 ↘  
   unit  A 8 →  
   veto  B 6 ↘  
    via  G 2 ↙  
    wah  I 2 ↑  
  witty  J 6 ←  


END

my $jvm = q:to/END/;
     A B C D E F G H I J
   0 y s h e a R a n o v
   1 a e h r b s O p i y
   2 d n r s e u e S c l
   3 g e k b i m t k E e
   4 T y c l u n a r y T
   5 i A p i e a i r c l
   6 a h C d r a m m k n
   7 a g p O b e e v i z
   8 a e s u D y l a o d
   9 m l e h c E v c p f

  Words used:
      aaa  A 6 ↓  
    ankle  A 1 ↘  
   aubrey  F 5 ↖  
      bee  E 7 →  
   cleric  H 9 ↖  
      cpa  I 2 ↖  
      crt  I 5 ↖  
      cup  E 9 ↖  
      day  A 2 ↑  
 diminish  J 8 ↖  
     dram  D 6 →  
      ely  J 3 ↑  
      fpc  J 9 ←  
      gel  B 7 ↓  
      gyp  A 3 ↘  
     helm  D 9 ←  
   lunary  D 4 →  
    lykes  J 5 ↖  
      nov  H 0 →  
      phi  C 7 ↖  
      poi  I 9 ↑  
   remark  D 1 ↘  
      sea  C 8 ←  
     shea  B 0 →  
     tube  G 3 ↖  
     vain  G 9 ↗  
      viz  H 7 →  
      yea  F 8 ↑  
      yen  B 4 ↑  
      yip  J 1 ←  


END

my $imac-cronjob = q:to/END/;
     A B C D E F G H I J
   0 e e w o n R i n g w
   1 s e t r p r O l i o
   2 p n u t a t e S r h
   3 w b n q z b k c E c
   4 T i d w y e r i n T
   5 d A r s g o t a n i
   6 i t C e m i t r a w
   7 d t l O o o c b n f
   8 l a o c D t n e h g
   9 a n d p e E t h e n

  Words used:
     bel  F 3 ↗  
    burn  B 3 ↗  
    chow  J 3 ↑  
    coal  D 8 ←  
     coo  G 7 ←  
     did  A 7 ↑  
     dna  C 9 ←  
   dwyer  C 4 →  
     etc  E 9 ↗  
     faa  J 7 ↖  
   ghent  J 8 ←  
 hebraic  H 9 ↑  
     inc  J 5 ↖  
    iraq  G 0 ↙  
     keg  G 3 ↙  
     ltd  C 7 ←  
     nan  I 5 ↓  
     nih  H 0 ↘  
     nut  C 3 ↑  
  nutate  B 2 →  
     opt  D 0 ↘  
     pew  A 2 ↗  
     pot  D 9 ↖  
     rig  I 2 ↑  
     set  A 1 →  
    then  G 9 →  
    togs  G 5 ←  
     trw  B 6 ↗  
 wartime  J 6 ←  
     wee  C 0 ←  
    wire  A 3 ↘  
     zap  E 3 ↑  


END

use Test;
if qx/uname -a/ ~~ /'Mac-Pro'/ {
    is @res.join("\n"), chomp $*VM ~~ /jvm/ ?? $jvm !! $*IN.t ?? $moar-terminal !! $moar-cronjob;
} else {
    is @res.join("\n"), chomp $imac-cronjob
}
