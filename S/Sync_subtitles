#!/usr/bin/env raku
#u# https://www.rosettacode.org/wiki/Sync_subtitles
#c# 2024-06-22 <RC
#m# MOAR: BROKEN OK
#j# JVM:  BROKEN OK

my @res;

sub MAIN() {
   my @lines = 'ref/movie.srt'.IO.slurp;
   for 9, -9 -> $seconds {
      say "Original subtitle adjusted by {$seconds.fmt('%+d')} seconds.";
      for @lines -> $line {
         if $line ~~ /(\d ** 2 ':' \d ** 2 ':' \d ** 2 ',' \d ** 3) ' --> ' (\d ** 2 ':' \d ** 2 ':' \d ** 2 ',' \d ** 3)/ {
            my $start = adjust-time($0.Str, $seconds);
            my $end   = adjust-time($1.Str, $seconds);
            my $adjusted = $line;
            $adjusted ~~ s/\d ** 2 ':' \d ** 2 ':' \d ** 2 ',' \d ** 3 ' --> ' \d ** 2 ':' \d ** 2 ':' \d ** 2 ',' \d ** 3/$start ~ ' --> ' ~ $end/.Str;
            say $adjusted
         } else {
            say $line;
         }
      }
      say()
   }
}

sub adjust-time($time, $seconds) {
   my ($time_str, $milliseconds_str) = $time.split(',');
   my (\hh, \mm, \ss) = $time_str.split(':')>>.Int;
   my $milliseconds = $milliseconds_str.Int;
   my $datetime = DateTime.new(:year,     :month,      :day, 
                               :hour(hh), :minute(mm), :second(ss));
   given $datetime .= later(:seconds($seconds)) {
      return sprintf('%02d:%02d:%02d,%03d',.hour,.minute,.second,$milliseconds)
   }
}


=finish

Less brutal
# 20240621 Raku programming solution

grammar SRT { # loc.gov/preservation/digital/formats/fdd/fdd000569.shtml
   token TOP { ^ <subtitle>+ % \n $ }
   token subtitle { <index> \n <timecode> \n <text> \n? }
   token index { \d+ }
   token timecode { <timestamp> ' --> ' <timestamp> }
   token timestamp { \d ** 2 ':' \d ** 2 ':' \d ** 2 ',' \d ** 3 }
   token text { <line>+ % \n }
   token line { <-[\n]>+ }
}

sub parse-srt($srt-content) {
   my $parsed = SRT.parse($srt-content);
   return $parsed 
      ?? $parsed<subtitle>.map(-> $sub { {
            index    => $sub<index>.Str,
            start    => $sub<timecode><timestamp>[0].Str,
            end      => $sub<timecode><timestamp>[1].Str,
            text     => $sub<text>.Str
         }})
      !! Nil;
} 

sub adjust-time($time, $seconds) {
   my ($time_str, $milliseconds_str) = $time.split(',');
   my (\hh, \mm, \ss) = $time_str.split(':')>>.Int;
   my $milliseconds = $milliseconds_str.Int;
   my $datetime = DateTime.new(:year,     :month,      :day, 
                               :hour(hh), :minute(mm), :second(ss));
   given $datetime .= later(:seconds($seconds)) {
      return sprintf('%02d:%02d:%02d,%03d',.hour,.minute,.second,$milliseconds)
   }
}

sub adjust-subtitles(@subtitles, Int $seconds) {
   @subtitles.map({ $_<start> = adjust-time($_<start>, $seconds);
                    $_<end>   = adjust-time($_<end>  , $seconds);
                    $_                                        });
}

sub format-srt(@subtitles) {
   @subtitles.map({
       $_<index> ~ "\n" ~ $_<start> ~ " --> " ~ $_<end> ~ "\n" ~ $_<text> ~ "\n"
   }).join("\n");
}

my @subtitles = parse-srt($*IN.slurp) or die;

for 9, -9 -> \N {
   my @adjusted-subtitles = adjust-subtitles(@subtitles.deepmap(*.clone), N);
   say "Original subtitle adjusted by {N.fmt('%+d')} seconds.";
   say format-srt(@adjusted-subtitles);
}

You may Attempt This Online!



END

.say for @res;
my $ref = q:to/END/;

use Test;
#my $ref = $*VM ~~ /jvm/ ?? $jvm !! $moar;
#is @res.join("\n"), chomp $ref;
#is @res.join('').subst(/<ws>/, '', :g), $ref.subst(/<ws>/, '', :g);
