#!/usr/bin/env raku
#u# https://www.rosettacode.org/wiki/Sorting_algorithms/Quicksort
#c# 2023-09-29 <RC
#m# MOAR: OK
#j# JVM:  BROKEN

#| Recursive, quicksort implementation
multi quicksort(@unsorted where @unsorted.elems < 2) { @unsorted }
multi quicksort(@unsorted) {
    my $pivot = @unsorted.pick;
    my %class{Order} is default([]);
    %class = @unsorted.classify: * cmp $pivot;
    |quicksort(%class{Less}), |%class{Same}, |quicksort(%class{More})
}

#| Recursive, parallel, quicksort implementation
multi quicksort-parallel(@unsorted where @unsorted.elems < 2) { @unsorted }
multi quicksort-parallel(@unsorted) {
    my %class{Order} is default([]);
    my $pivot = @unsorted.pick;
    %class = @unsorted.classify( * cmp $pivot );
    my $less = start { samewith(%class{Less}) };
    my $more = samewith(%class{More});
    await $less andthen |$less.result, |%class{Same}, |$more
}

#=Â« Implementation Notes:
* uses the current thread for More partition
* recursion on Less partition can create a large number of new threads
* samewith() refactors out the actual name of the routine.
Â»

use Test;
my @testcases =
#   () => (),
#   <a>.List => <a>.List,
#   <a a> => <a a>,
#   <b a> => <a b>,
    <h b a c d f e g> => <a b c d e f g h>,
    (2, 3, 1, 4, 5) => (1, 2, 3, 4, 5),
    <a ðŸŽ® 3 z 4 ðŸ§> => <a ðŸŽ® 3 z 4 ðŸ§>.sort,
;

for &quicksort, &quicksort-parallel ->  &fun {
    say &fun.name;
    is-deeply &fun(.key), .value, .key ~ " => " ~ .value for @testcases;
}
