#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Null_object
#c# 2019-09-21 <RC
#m# MOAR: OK
#j# JVM:  OK

my @res;

#`{{
In Perl 6 you can name the concept of Nil, but it not considered an object,
but rather the absence of an object, more of a "bottom" type. The closest
analog in real objects is an empty list, but an empty list is considered
defined, while Nil.defined always returns false. Nil is what you get if you
try to read off the end of a list, and () is just very easy to read off the
end of... :-)

If you try to put Nil into a container, you don't end up with a container
that has Nil in it. Instead the container reverts to an uninitialized state
that is consistent with the declared type. Hence, Perl 6 has the notion of
typed undefined values, that are real objects in the sense of "being
there", but are generic in the sense of representing type information
without being instantiated as a real object. We call these type objects
since they can stand in for real objects when one reasons about the types
of objects. So type objects fit into the type hierarchy just as normal
objects do. In physics terms, think of them as "type charge carriers" that
are there for bookkeeping between the "real" particles.

All type objects derive from Mu, the most-undefined type object, and the
object most like "null" in many languages. All other object types derive
from Mu, so it is like Object in other languages as well, except Mu also
encompasses various objects that are not discrete, such as junctions. So
Perl 6 distinguishes Mu from Any, which is the type that functions the most
like a discrete, mundane object.

Mostly the user doesn't have to think about it. All object containers
behave like "Maybe" types in Haskell terms; they may either hold a valid
value or a "nothing" of an appropriate type.  Most containers default to an
object of type Any so you don't accidentally send quantum superpositions
(junctions) around in your program.
}}

my $var;
@res.push: $var.WHAT.raku;      # Any()
$var = 42;
@res.push: $var.WHAT.raku;      # Int()
@res.push: $var.defined;        # True
$var = Nil;
@res.push: $var.WHAT.raku;      # Any()
@res.push: $var.defined;        # False

# You can declare a variable of type Mu if you wish to propagate superpositional types:

my Mu $junction;
@res.push: $junction.WHAT.raku; # Mu()
$junction = 1 | 2 | 3;
@res.push: $junction.WHAT.raku; # Junction()

# Or you can declare a more restricted type than Any

my Str $str;
@res.push: $str.WHAT.raku;      # Str()
$str = "I am a string.";
@res.push: $str.WHAT.raku;      # Str()
#$str = 42;                     # (fails) ## commented out for testing

#`{{
But in the Perl 6 view of reality, it's completely bogus to ask for a way
"to see if an object is equivalent to the null object." The whole point of
such a non-object object is that it doesn't exist, and can't participate in
computations. If you think you mean the null object in Perl 6, you really
mean some kind of generic object that is uninstantiated, and hence
undefined. One of those is your "null object", except there are many of
them, so you can't just check for equivalence. Use the defined predicate
(or match on a subclass of your type that forces recognition of abstraction
or definedness).

Perl 6 also has Failure objects that, in addition to being undefined
carriers of type, are also carriers of the reason for the value's
undefinedness. We tend view them as lazily thrown exceptions, at least
until you try to use them as defined values, in which case they're thrown
for real.
}}

.say for @res;

my $ref = q:to/END/;
Any
Int
True
Any
False
Mu
Junction
Str
Str
END

use Test;
is @res.join("\n"), chomp $ref;
