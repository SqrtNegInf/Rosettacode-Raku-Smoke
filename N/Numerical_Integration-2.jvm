#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Numerical_Integration
#c# 2015-12-16 <RC
#t# toodamnslow
#m# MOAR: OK
#j#  JVM: OK
#n# 2 out of 3 ain't bad, but then: java.lang.OutOfMemoryError: Java heap space

#`{
::STDERR::
java.lang.OutOfMemoryError: Java heap space
  in sub midrect at N/Numerical_Integration-2.1 line 28
  in sub try'em at N/Numerical_Integration-2.1 line 62
  in block <unit> at N/Numerical_Integration-2.1 line 110
}

use MONKEY-SEE-NO-EVAL; #DH

# Works with: Rakudo version 2015-09-24
sub leftrect(&f, $a, $b, $n) {
    my $h = ($b - $a) / $n;
    $h * [+] do f($_) for $a, $a+$h ... $b-$h;
}

sub rightrect(&f, $a, $b, $n) {
    my $h = ($b - $a) / $n;
    $h * [+] do f($_) for $a+$h, $a+$h+$h ... $b;
}

sub midrect(&f, $a, $b, $n) {
    my $h = ($b - $a) / $n;
    $h * [+] do f($_) for $a+$h/2, $a+$h+$h/2 ... $b-$h/2;
}

sub trapez(&f, $a, $b, $n) {
    my $h = ($b - $a) / $n;
    # Too many arguments in flattening array.
#    $h / 2 * [+] f($a), f($b), |do f($_) * 2 for $a+$h, $a+$h+$h ... $b-$h;
     my $partial-sum += f($_) * 2 for $a+$h, $a+$h+$h ... $b-$h; #DH
     $h / 2 * [+] f($a), f($b), $partial-sum;
}

sub simpsons(&f, $a, $b, $n) {
    my $h = ($b - $a) / $n;
    my $h2 = $h/2;
    my $sum1 = f($a + $h2);
    my $sum2 = 0;

    for $a+$h, *+$h ... $b-$h {
        $sum1 += f($_ + $h2);
        $sum2 += f($_);
    }
    ($h / 6) * (f($a) + f($b) + 4*$sum1 + 2*$sum2);
}

sub try'em($f, $a, $b, $n, $exact) {
    my @r0;
    @r0.push: "$f\n   in [$a..$b] / $n\n";
    @r0.push: '              exact result: '~ $exact;

    my (@r1,@r2,@r3,@r4,@r5);
    my &f;
    EVAL "&f = $f";
    @r1.push: '     rectangle method left: '~ leftrect  &f, $a, $b, $n;
    @r2.push: '    rectangle method right: '~ rightrect &f, $a, $b, $n;
    @r3.push: '      rectangle method mid: '~ midrect   &f, $a, $b, $n;
    @r4.push: 'composite trapezoidal rule: '~ trapez    &f, $a, $b, $n;
    @r5.push: '   quadratic simpsons rule: '~ simpsons  &f, $a, $b, $n;
    @r0, @r1, @r2, @r3, @r4, @r5;
}

# Note that these integrations are done with rationals rather than floats, so should be fairly precise (though of course with so few iterations they are not terribly accurate (except when they are)).  Some of the sums do overflow into Num (floating point)--currently rakudo allows 64-bit denominators--but at least all of the interval arithmetic is exact.

use Test;

my $ref1 = q:to/END1/;
{ $_ ** 3 }
   in [0..1] / 100
              exact result: 0.25
     rectangle method left: 0.245025
    rectangle method right: 0.255025
      rectangle method mid: 0.249988
composite trapezoidal rule: 0.250025
   quadratic simpsons rule: 0.25
END1
my @res1 = try'em '{ $_ ** 3 }', 0, 1, 100, 0.25;
.say for @res1; say '';
#is @res1.join("\n"), chomp $ref1;

my $ref2 = q:to/END2/;
1 / *
   in [1..100] / 1000
              exact result: 4.605170185988092
     rectangle method left: 4.654991057514682
    rectangle method right: 4.556981057514681
      rectangle method mid: 4.604762548678376
composite trapezoidal rule: 4.605986057514682
   quadratic simpsons rule: 4.605170384957145
END2
my @res2 = try'em '1 / *', 1, 100, 1000, log(100);
.say for @res2; say '';
#is @res2.join("\n"), chomp $ref2;

my $ref3 = q:to/END3/;
*.self
   in [0..5000] / 5000000
              exact result: 12500000
     rectangle method left: 12499997.5
    rectangle method right: 12500002.5
      rectangle method mid: 12500000
composite trapezoidal rule: 12500000
   quadratic simpsons rule: 12500000
END3
my @res3 = try'em '*.self', 0, 5_000, 5_000_000, 12_500_000;
.say for @res3; say '';
#is @res3.join("\n"), chomp $ref3;

my $ref4 = q:to/END4/;
*.self
   in [0..6000] / 6000000
              exact result: 18000000
     rectangle method left: 17999997
    rectangle method right: 18000003
      rectangle method mid: 18000000
composite trapezoidal rule: 18000000
   quadratic simpsons rule: 18000000
END4
my @res4 = try'em '*.self', 0, 6_000, 6_000_000, 18_000_000;
.say for @res4; say '';
#is @res4.join("\n"), chomp $ref4;
